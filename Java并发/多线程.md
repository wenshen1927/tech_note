# Java线程的内存模型
    线程A <--> 本地内存 <--> 主内存
线程A拥有自己的本地内存，当他需要获取主内存中共享变量的值得时候，他就从主内存copy一份变量，自己操作，操作完再立刻写入主内存。
# 保证线程安全的原则：
+ 有序性
+ 可见性
+ 原子性

# 1、有序性：
1、指令重排
（https://tech.meituan.com/java-memory-reordering.html）
从Java源代码到最终实际执行的指令序列，会经过三种指令重新排序:

1. 编译器优化重排序
2. 指令级并行重排序
3. 内存系统重排序

2、指令重排与线程有序性：
+ 单线程指令重排不会影响最终结果，最后代码执行的结果和代码顺序执行时一致的，这样的结果是有序的；
+ 处理器在进行重排的时候回考虑代码之间的数据依赖性，也会得到有序性结果；
+ 多线程环境中线程交替执行，会破坏有序性，结果无法预测。

# 2、可见性：
可见性是指当一个线程修改了共享变量的值，那么其他的线程能够马上得知这个修改的值：

线程A执行完共享变量值，立马写入主内存，当线程B需要使用共享变量的时候，需要从主内存中查看变量是否被修改（可用violate 或 锁来解决）
（violate 只能保证可见性，不能保证原子性。一般修饰int 或 boolean 这种状态变量。防止语句重排。)

# 3、原子性：
一个操作是不可中断的，即使在多线程的环境下，一个操作一旦开始就不被其他线程影响。（和数据库的事务是一样的）
